import numpy as np
import pandas as pd
import yfinance as yf

def _flatten_yf_columns(df: pd.DataFrame) -> pd.DataFrame:
    if isinstance(df.columns, pd.MultiIndex):
        df = df.copy()
        df.columns = [c[0] if isinstance(c, tuple) else c for c in df.columns]
    return df

def load_spy_for_garch(
    start: str = "2005-01-01",
    end: str | None = None,
    use_log_returns: bool = True,
    scale_returns: float = 100.0,
    test_start: str = "2019-01-01",
):
    df = yf.download(
        "SPY",
        start=start,
        end=end,
        interval="1d",
        auto_adjust=True,
        actions=False,
        progress=False,
    )
    df = _flatten_yf_columns(df)
    if df.empty:
        raise RuntimeError("No data returned from yfinance.")

    df = df[~df.index.duplicated(keep="first")].sort_index()

    px = df["Close"].dropna().copy()
    px.name = "price"

    r = np.log(px).diff() if use_log_returns else px.pct_change()
    r = (r.dropna() * scale_returns).copy()
    r.name = "ret"

    # Realized variance targets aligned to forecast origin t
    s2 = r.pow(2)

    rv1 = s2.shift(-1).copy()
    rv1.name = "rv1"

    rv20 = s2.shift(-1).rolling(20).sum().shift(-19).copy()
    rv20.name = "rv20"

    test_start_ts = pd.Timestamp(test_start)
    train_returns = r.loc[r.index < test_start_ts].copy()
    test_returns = r.loc[r.index >= test_start_ts].copy()

    return {
        "prices": px,
        "returns": r,
        "train_returns": train_returns,
        "test_returns": test_returns,
        "rv1": rv1.dropna(),
        "rv20": rv20.dropna(),
        "raw_df": df,
    }
# Step 1: Model-free evidence of volatility mean reversion using SPY daily returns (yfinance)
# Assumes you already have `data` from load_spy_for_garch(...) and therefore `data["returns"]`
# pip install statsmodels

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss


def build_realized_vol_proxies(returns: pd.Series, m: int = 20) -> pd.DataFrame:
    """
    returns: daily scaled returns (e.g., 100*log-return), indexed by date.
    m: window length in trading days (e.g., 20 ~ 1 month)

    Produces trailing realized variance RV_m(t) = sum_{i=0..m-1} r_{t-i}^2
    and log-RV plus realized vol.
    """
    r = returns.dropna().sort_index()
    rv = r.pow(2).rolling(m).sum()
    out = pd.DataFrame({
        f"rv{m}": rv,
        f"log_rv{m}": np.log(rv),
        f"rvol{m}": np.sqrt(rv),  # volatility in same units as returns (percent)
    }).dropna()
    return out


def ar1_mean_reversion(log_rv: pd.Series) -> dict:
    """
    Fits AR(1): v_{t} = a + b v_{t-1} + e_t on log realized variance v_t.
    Returns fitted model + implied half-life (in days) if |b|<1 and b>0.
    Uses HAC standard errors (Newey-West).
    """
    v = log_rv.dropna()
    v_lag = v.shift(1).dropna()
    v_now = v.loc[v_lag.index]

    X = sm.add_constant(v_lag)
    ols = sm.OLS(v_now, X).fit(cov_type="HAC", cov_kwds={"maxlags":20})

    a = ols.params["const"]
    b = ols.params[v_lag.name]

    # Half-life for AR(1) (if 0<b<1)
    half_life = None
    if (b > 0) and (abs(b) < 1):
        half_life = float(np.log(0.5) / np.log(b))

    return {"model": ols, "a": float(a), "b": float(b), "half_life_days": half_life}


def pullback_regression(log_rv: pd.Series) -> dict:
    """
    Pull-back regression: Δv_t = c + phi * v_{t-1} + u_t
    Mean reversion corresponds to phi < 0.
    Uses HAC standard errors.
    """
    v = log_rv.dropna()
    dv = v.diff().dropna()
    v_lag = v.shift(1).loc[dv.index]

    X = sm.add_constant(v_lag)
    ols = sm.OLS(dv, X).fit(cov_type="HAC", cov_kwds={"maxlags":20})

    c = ols.params["const"]
    phi = ols.params[v_lag.name]

    return {"model": ols, "c": float(c), "phi": float(phi)}


def stationarity_tests(log_rv: pd.Series) -> dict:
    """
    ADF: H0 = unit root (non-stationary). Low p => reject => stationary.
    KPSS: H0 = stationary. High p => fail to reject => stationary.
    """
    v = log_rv.dropna()

    adf_stat, adf_p, _, _, adf_crit, _ = adfuller(v, autolag="AIC")
    kpss_stat, kpss_p, _, kpss_crit = kpss(v, regression="c", nlags="auto")

    return {
        "adf_stat": adf_stat, "adf_p": adf_p, "adf_crit": adf_crit,
        "kpss_stat": kpss_stat, "kpss_p": kpss_p, "kpss_crit": kpss_crit
    }


r = data["returns"]  # scaled daily returns, e.g. percent log-returns
m = 20

rv_df = build_realized_vol_proxies(r, m=m)
v = rv_df[f"log_rv{m}"]
v.name = f"log_rv{m}"  # ensure a stable name for regression output

# AR(1) on log RV
ar1 = ar1_mean_reversion(v)

# Pull-back regression on log RV
pb = pullback_regression(v)

# Stationarity tests
tests = stationarity_tests(v)

print(f"AR(1) on log RV{m}: v_t = a + b v_(t-1) + e_t")
print(f"  b = {ar1['b']:.6f}")
print(f"  half-life (days) = {ar1['half_life_days']}")
print(ar1["model"].summary())

print(f"\nPull-back: Δv_t = c + phi*v_(t-1) + u_t")
print(f"  phi = {pb['phi']:.6f}  (mean reversion if phi < 0)")
print(pb["model"].summary())

print("\nStationarity tests on log RV:")
print(f"  ADF p-value  = {tests['adf_p']:.6g} (reject unit root if small)")
print(f"  KPSS p-value = {tests['kpss_p']:.6g} (fail to reject stationarity if large)")

ax = rv_df[f"rvol{m}"].plot(title=f"SPY trailing realized volatility: sqrt(RV{m})", figsize=(10,4))
ax.set_ylabel("Vol (percent)")
plt.show()

ax = rv_df[f"log_rv{m}"].plot(title=f"SPY log realized variance: log(RV{m})", figsize=(10,4))
ax.set_ylabel("log variance")
plt.show()

#scatter to visualize mean reversion (AR(1) slope)
v_lag = v.shift(1)
plt.figure(figsize=(5,5))
plt.scatter(v_lag.dropna(), v.loc[v_lag.dropna().index], s=5)
plt.xlabel(f"log RV{m} (t-1)")
plt.ylabel(f"log RV{m} (t)")
plt.title("Mean reversion visual: AR(1) on log realized variance")
plt.show()
from __future__ import annotations

